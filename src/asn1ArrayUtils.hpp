/*
 * H2020 ESROCOS Project
 * Company: GMV Aerospace & Defence S.A.U.
 * Licence: GPLv2
 */

/*
 * Utility macros for copying arrays.
 */

#ifndef ASN1ARRAYUTILS_HPP
#define ASN1ARRAYUTILS_HPP

#include <iostream>
#include "asn1StringUtils.h"

// Array size as fixed by Rock2Taste
#define ARRAY_SIZE ((int)60)


// Templates for converting between ASN.1 arrays and std::vector
// The relays on the following structure of the C types generated by 
// the ASN.1 compiler:
// 
//     SEQUENCE (SIZE (n)) OF type;
//
// becomes:
// 
//     struct {
//        int nCount; 
//        type arr[n];
//     };
// 
// The following templates receive the vector and the fields nCount and
// arr of the array type.


// Copy from array to vector using a conversion function
// Usage:
//      array_from_asn1_func(vector, array.nCount, array.arr, convertFunction);
template<typename T1, typename T2>
void array_from_asn1_func(std::vector<T1>& outVector, int count, const T2 array[], void convert(T1&, const T2&))
{
    outVector.resize(count);
    for (int i = 0; i < count; i++)
    {
        convert(outVector.at(i), array[i]);
    }
}

// Copy from array to vector using assignment (for basic types).
// Usage:
//      array_from_asn1_assign(vector, array.nCount, array.arr);
template<typename T1, typename T2>
void array_from_asn1_assign(std::vector<T1>& outVector, int count, const T2 array[])
{
    outVector.resize(count);
    for (int i = 0; i < count; i++)
    {
        outVector.at(i) = array[i];
    }
}

// Copy from array to vector for string types (T-StringN).
// Usage:
//      array_from_asn1_string(vector, array.nCount, array.arr, maxStringSize);
template<typename T1, typename T2>
void array_from_asn1_string(std::vector<T1>& outVector, int count, const T2 array[], asn1SccT_UInt32 stringSize)
{
    outVector.resize(count);
    for (int i = 0; i < count; i++)
    {
        StringN_fromAsn1(outVector.at(i), array[i], stringSize);
    }
}



// Copy from vector to array using a conversion function. Elements 
// above the maximum are discarded with a warning message.
// Usage:
//      array_to_asn_func(&array.nCount, array.arr, vector, convertFunction, "typeName");
// The errStr parameter is used fror printing a warning message if the 
// vector has too many elements: "typeName discarded (max is N)."
template<typename T1, typename T2>
void array_to_asn1_func(int* outCount, T1 outArray[], const std::vector<T2> vector, void convert(T1&, const T2&), const char* errStr, int maxSize = ARRAY_SIZE)
{
    *outCount = vector.size();
    if (*outCount > maxSize)
    {
        std::cerr << errStr << " discarded (max is " << maxSize << ")." << std::endl;
        *outCount = maxSize;
    }
    for (int i = 0; i < *outCount; i++)
    {
        convert(outArray[i], vector[i]);
    }
}

// Copy from vector to array using assignment. Elements 
// above the maximum are discarded with a warning message.
// Usage:
//      array_to_asn_assign(&array.nCount, array.arr, vector, "typeName");
// The errStr parameter is used fror printing a warning message if the 
// vector has too many elements: "typeName discarded (max is N)."
template<typename T1, typename T2>
void array_to_asn1_assign(int* outCount, T1 outArray[], const std::vector<T2> vector, const char* errStr, int maxSize = ARRAY_SIZE)
{
    *outCount = vector.size();
    if (*outCount > maxSize)
    {
        std::cerr << errStr << " discarded (max is " << maxSize << ")." << std::endl;
        *outCount = maxSize;
    }
    for (int i = 0; i < *outCount; i++)
    {
        outArray[i] = vector[i];
    }
}

// Copy from vector to array for strings. Elements 
// above the maximum are discarded with a warning message.
// Usage:
//      array_to_asn_string(&array.nCount, array.arr, vector, maxStringSize, "typeName");
// The errStr parameter is used fror printing a warning message if the 
// vector has too many elements: "typeName discarded (max is N)."
template<typename T1, typename T2>
void array_to_asn1_string(int* outCount, T1 outArray[], const std::vector<T2> vector, asn1SccT_UInt32 stringSize, const char* errStr, int maxSize = ARRAY_SIZE)
{
    *outCount = vector.size();
    if (*outCount > maxSize)
    {
        std::cerr << errStr << " discarded (max is " << maxSize << ")." << std::endl;
        *outCount = maxSize;
    }
    for (int i = 0; i < *outCount; i++)
    {
        StringN_toAsn1(outArray[i], vector[i], stringSize);
    }
}



#endif //ASN1ARRAYUTILS_HPP
